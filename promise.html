<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Promise</title>
</head>
<body>

<img id="img" src="" alt="">

<script>
    /**
     * Promise是怎么解决回调地狱问题的
     * 回调地狱有以下2个问题：
     * 1、多层嵌套问题
     * 2、每个任务处理完后有两个结果（成功或失败），那么需要在每个任务完成后都要分别判断处理这两种可能的结果
     * @param a
     * @returns {Promise<any>}
     */

    function fun(a) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if(a === 'c') {
                    console.log('fail')
                    reject(a)
                }else {
                    console.log('成功')
                    resolve(a)
                }
            }, 1000)
        })
    }

    // 解决回调地狱1：回调函数延迟绑定（then方法中参数就是回调函数）
    var x = fun('a').then(res => {
        console.log(res)
        return fun('b')  // 返回一个Promise给参数x，然后在 x 后面可以依次完成链式调用
    })
    // 解决回调地狱2：返回值穿透
    x.then(res => {
        console.log(res)
    })

    // 利用返回值穿透特性，可以将深层次的回调嵌套写成以下形式
    fun('a').then(res => {
        console.log(res)
        return fun('b')
    }).then(res => {
        console.log(res)
        return fun('c')
    }).then(res => {
        console.log(res)
        return fun('d')
    }).catch(err => {  // 解决回调地狱3：错误冒泡，这样前面产生的错误就会一直向后传递，被catch接收到
        console.log('catch')
        console.log(err)
    })

    /*TODO  Promise 解决回调地狱的效果也比较明显：实现链式调用，解决多层嵌套问题；实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题。*/

    function getBanner() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('getBanner done')
            }, 100)
        })
    }
    function getList() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('getList done')
            }, 500)
        })
    }
    function getDetail() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('getDetail fail')
            }, 2500)
        })
    }

    /**************Promise 的静态方法******************/
    /**
     * Promise.all方法
     * 参数为一个可以迭代的对象，比如Array
     * 此方法对于汇总多个Promise结果很有用
     * 1、当所有结果成功返回时，进入then方法，按照 [请求顺序(数组参数中的顺序)] 返回成功，结果为一个数组
     * 2、当其中有一个返回失败时，就进入catch方法，返回的是最先失败的那个reject
     */
    Promise.all([getBanner(), getList(), getDetail()]).then(res => {
        console.log(res)  // ['getBanner done', 'getList done', 'getDetail fail']
    }).catch(err => {
        console.log(err) // getList done
    })

    /**
     * Promise.allSettled方法
     * 参数为一个可以迭代的对象，比如Array
     * 执行完成后没有失败状态，可以拿到所有Promise的状态，不管其是否成功
     */
    Promise.allSettled([getBanner(), getList(), getDetail()]).then(res => {
        console.log(res)  // [{"status":"rejected","reason":"getBanner done"},{"status":"rejected","reason":"getList done"},{"status":"rejected","reason":"getDetail fail"}]
    }).catch(err => {
        console.log(err)
    })


    /**
     * Promise.race
     * 参数为一个可以迭代的对象，比如Array
     * 方法返回一个Promise,只要参数中有一个Promise率先改变状态，则race的状态就跟着这个率先改变状态的Promise改变
     */
    Promise.race([getBanner(), getList(), getDetail()]).then(res => {
        console.log(res)
    }).catch(err => {
        console.log(err)
    })


    /**
     * Promise.race的应用
     * 判断图片加载是否超时
     * @type {HTMLElement}
     */
    var img = document.getElementById('img')
    // 加载图片函数
    function loadImg() {
        return new Promise(resolve => {
            img.src = 'http://www.baidu.com/img/flexible/logo/pc/resut.png'
            img.onload = function () {
                console.log(666)
                resolve(img)
            }
        })
    }
    // 超时函数
    function timeout() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                img.src = './img/1.jpg';
                reject('图片加载超时')
            }, 50)
        })
    }
    Promise.race([loadImg(), timeout()]).then(res => {
        console.log(res)
    }).catch(err => {
        console.log(err)
    })


</script>
</body>
</html>